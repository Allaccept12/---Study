**로버트 마틴은 소프트웨어 모듈이 가져야하는 세가지 기능에 관해 설명한다. 모듈이란 크기와 상관없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임이의 요소를 의미한다.**

목적1 : 실행중에 제대로 동작하는 것. 이것은 모듈의 존재 이유라고 할 수 있다. 
목적2 : 변경을 위해 존재하는 것. 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야한다. 변경하기 어려운 모듈은 제대로 동작하더라도 **개선**해야한다.
목적3 : 코드를 ㅇ ㅣㄹㄱ는 사람과 의사소통하는 것. 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다. 읽는 사람과 의사소통할 수 없는 모듈은 개선해야 한다.

> 모든 모듈은 제대로 실행돼야하고, 변경이 용이해야하며, 이해하기 쉬워야 한다. 앞서 커밋한 프로그램은 목적1은 달성되었지만 목적2와 목적3은 만족시키지 못한다. 

# 1. 예상을 빗나가는 코드

마지막 Theater class의 enter메서드를 설명 해보라. 
> 소극장은 먼저 관람객의 가방안에 초대장이 들어있는지 확인하고, 만약 초대장이 들어있다면 이벤트에 당첨된 관람객이므로 판매원에게서 받은 티켓을 관람객의 가방안에 넣어준다.
 가방안에 초대장이 없다면 티켓을 판매한다. 이격우 소극장은 관람개그이 가방에서 티켓금액만큼을 차감후에 매표소에 금액을 증가시킨다.
 마지막으로 소극장은 관람객의 가방안에 티켓을 넣어줌으로써 관람객의 입장절차가 끝이난다.

***문제1. 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재다.***
- 관람객의 입장에서 소극장이라는 객체가 초대장을 확인하기위해서 자기 가방을 마음대로 열어본다는데 있다. 
- 판매원의 입장에서는 소극장이 허락없이 매표소에 보관 중인 티켓과 현금에 마음대로 접근할 수 있다. 더 큰 문제는 티켓을 꺼내 관람객의 가방에 집어넣고 관람객에게서 받은 돈을 매표소에 적립하는 일을 소극장이
다한다는 점이다. 
> 판매원은(관람객은) 가만히 있는데도 자동으로 티켓이 판매되고, 가방에 들어가고, 본인의 돈이 빠져나가고, 티켓오피스에 돈이 쌓이는 광경을 목격 하게된다.

***문제2. 코드는 이해하기 위해서 세부적으로 내용을 한꺼번에 이해하고 있어야 한다.***

```java
public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
```
- Theater의 enter메서드를 이해하기 위해서는 Audience가 Bag를 가지고 있고 Bag 안에는 현금과 티켓이 들어 있으며 TicketSeller가 TicketOffice에서 티켓을 판매하고, TicketOffice안에 돈과 티켓이 보관돼 있다는 모든 사실을 동시에 기억하고 있어야한다. 
- 즉, 하나의 클래스나 메서드에서 너무 많은 세부상을 다루기 때문에 코드 작성자 뿐 아니라 읽는 사람도 큰 부담을 느끼게 된다.

# 2. 변경에 취약한 코드(OCP위반, SRP위반 등등)

- 관람객이 현금과 초대장을 보관하기 위해 항상 가방을 들고 다닌다고 가정한다. 또한 판매원이 매표소에서만 티켓을 판매한다고 가정한다. 
- 관람객이 가방을 들고 있지 않다면? 관람객이 현금이 아니라 카드를 이용한다면? 판매원이 티켓을 매표소 밖에서 판매해야한다면? 
> 이 순간 프로그램은 흔들린다. 

- 이것은 객체사이의 **의존성**과 관련된 문제다. 문제는 의존성이 변경과 관련돼 있다는 점이다. 의존성은 변경에 대한 영향을 암시한다. 
- 의존성이라는 말은 어떤 객체가 변경될 떄 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.

***그렇다고 의존성을 없애는 것이 정답이 아니다. 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것이 정답에 가깝다고 볼 수 있다.***

> 객체간 의존성이 강한경우 **결합도**가 높다고 말한다. 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이어야한다.



